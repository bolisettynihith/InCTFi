#!/usr/bin/env python3
import pickle, gmpy2, hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from main import RNG

val = pickle.load(open('enc.pickle', 'rb'))

def solve(inp):
	mod = int(gmpy2.next_prime(2**64))
	a, c = sum(inp[:2])%mod, sum(inp[2:])%mod
	b, d = (inp[1]+a)%mod, (inp[3]+c)%mod
	return [a,b,c,d]

def get_state(out):
	st = []
	for i in range(0, len(out), 4):
		st += solve(out[i:i+4])
	return st

def reverse_state(seed):
	sze = 64
	mod = int(gmpy2.next_prime(2**sze))
	hsze = sze//2
	pad = 0xDEADC0DE
	for i in range(sze-1, -1, -1):
		r1 = seed[i]
		r2 = seed[(i+hsze)%sze]
		seed[i] = ((r1*int(gmpy2.invert(r2, mod)))%mod)^pad
	return seed

def atk(val):
	out = [int(val[i:i+16], 16) for i in range(0, len(val), 16)]
	assert len(out) == 64
	seed = get_state(out)
	obj = RNG(0, reverse_state(seed))
	return ''.join([format(obj.next(), '016x') for i in range(64)])

def decrypt(msg, iv, key):
	key = hashlib.sha256(key).digest()[:16]
	cipher = AES.new(key, AES.MODE_CBC, iv)
	try:
		out = unpad(cipher.decrypt(msg), 16)
		assert b'inctf{' in out
		return  out
	except:
		return False

def main(val):
	out1 = atk(val['leak'])
	print(out1)
	cip = bytes.fromhex(val['cip'])
	iv = bytes.fromhex(val['iv'])
	return decrypt(cip, iv, bytes.fromhex(out1))

if __name__ == '__main__':
	print(main(val))